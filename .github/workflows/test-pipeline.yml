name: Test Pipeline

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Type of tests to run'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - local
          - integration
      skip_cleanup:
        description: 'Skip testbed cleanup for debugging'
        required: false
        default: false
        type: boolean

env:
  TESTBED_PREFIX: ci-test-${{ github.run_id }}

jobs:
  workflow-validation:
    runs-on: ubuntu-latest
    if: github.event.inputs.test_type != 'integration'
    steps:
      - name: Checkout code (no submodules)
        uses: actions/checkout@v4
        with:
          submodules: false

      - name: Validate workflow YAML syntax
        run: |
          echo "ğŸ” Validating GitHub Actions workflow syntax..."
          
          # Check if all workflow files are valid YAML
          for workflow in .github/workflows/*.yml; do
            echo "Checking YAML syntax for $workflow..."
            if python -c "import yaml; yaml.safe_load(open('$workflow'))" 2>/dev/null; then
              echo "âœ… $workflow has valid YAML syntax"
            else
              echo "âŒ YAML syntax error in $workflow"
              exit 1
            fi
          done
          
          echo "âœ… All workflow files have valid YAML syntax"

  integration-tests:
    runs-on: ubuntu-latest
    if: github.event.inputs.test_type != 'local'
    steps:
      - name: Checkout code with submodules
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Verify doctl authentication
        run: |
          doctl account get
          doctl compute ssh-key list --format Name

      - name: Create integration testbed
        id: create-testbed
        run: |
          testbed_name="${TESTBED_PREFIX}-integration"
          echo "testbed_name=$testbed_name" >> $GITHUB_OUTPUT

          echo "ğŸš€ Creating integration testbed: $testbed_name"
          ./tests/0_do-testbed_cli.sh create "$testbed_name"

      - name: Test Docker environment on testbed
        run: |
          testbed_name="${{ steps.create-testbed.outputs.testbed_name }}"

          # Get testbed info
          droplet_name=$(doctl compute droplet list --format Name --no-header | grep "$testbed_name" | head -1)
          droplet_ip=$(doctl compute droplet get "$droplet_name" --format PublicIPv4 --no-header)

          echo "ğŸ³ Testing Docker environment on $droplet_ip..."

          # Test Docker functionality
          ssh -o StrictHostKeyChecking=no "root@$droplet_ip" << 'EOF'
            set -e
            echo "=== Docker Version ==="
            docker --version
            docker compose --version

            echo "=== Testing Multi-arch Support ==="
            docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
            docker buildx create --name test-builder --use || true
            docker buildx inspect --bootstrap

            echo "=== Testing Base Image Pulls ==="
            docker pull node:18-alpine
            docker pull python:3.12-slim
            docker pull postgres:13-alpine

            echo "=== System Resources ==="
            df -h /
            free -h
            nproc

            echo "âœ… Docker environment test passed"
          EOF

      - name: Test ColmenaOS deployment
        run: |
          testbed_name="${{ steps.create-testbed.outputs.testbed_name }}"

          echo "ğŸš€ Testing ColmenaOS deployment..."
          ./tests/0_do-testbed_cli.sh deploy "$testbed_name"

      - name: Run deployment health checks
        run: |
          testbed_name="${{ steps.create-testbed.outputs.testbed_name }}"
          droplet_name=$(doctl compute droplet list --format Name --no-header | grep "$testbed_name" | head -1)
          droplet_ip=$(doctl compute droplet get "$droplet_name" --format PublicIPv4 --no-header)

          echo "ğŸ” Running health checks on $droplet_ip..."

          # Extended health checks
          ssh -o StrictHostKeyChecking=no "root@$droplet_ip" << 'EOF'
            cd /root

            echo "=== Service Status ==="
            docker compose ps

            echo "=== Container Health ==="
            for container in $(docker ps --format "{{.Names}}"); do
              echo "Checking $container..."
              docker inspect "$container" --format "{{.State.Status}}: {{.State.Health.Status}}" || echo "No health check"
            done

            echo "=== Network Connectivity ==="
            # Test internal service connectivity
            timeout 10 docker compose exec -T backend curl -f http://db:5432 2>/dev/null && echo "DB connection: OK" || echo "DB connection: SKIP"

            echo "=== External Accessibility ==="
            # Test if services respond on their expected ports
            curl -f http://localhost:80 && echo "Frontend: OK" || echo "Frontend: FAILED"
            curl -f http://localhost:1080 && echo "Mailcrab: OK" || echo "Mailcrab: FAILED"

            echo "=== Resource Usage ==="
            docker stats --no-stream

            echo "âœ… Health checks completed"
          EOF

      - name: Cleanup testbed
        if: always() && !inputs.skip_cleanup
        run: |
          testbed_name="${{ steps.create-testbed.outputs.testbed_name }}"
          echo "ğŸ§¹ Cleaning up testbed: $testbed_name"
          ./tests/0_do-testbed_cli.sh destroy "$testbed_name" || echo "Cleanup warning: testbed may still exist"

      - name: Preserve testbed for debugging
        if: inputs.skip_cleanup
        run: |
          testbed_name="${{ steps.create-testbed.outputs.testbed_name }}"
          droplet_ip=$(doctl compute droplet get "$(doctl compute droplet list --format Name --no-header | grep "$testbed_name" | head -1)" --format PublicIPv4 --no-header)

          echo "ğŸ› Testbed preserved for debugging:"
          echo "  Name: $testbed_name"
          echo "  IP: $droplet_ip"
          echo "  SSH: ssh root@$droplet_ip"
          echo "  Cleanup: ./tests/0_do-testbed_cli.sh destroy $testbed_name"

  docker-basic-tests:
    runs-on: ubuntu-latest
    if: github.event.inputs.test_type != 'integration'
    steps:
      - name: Checkout code (no submodules)
        uses: actions/checkout@v4
        with:
          submodules: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Test Docker Compose Configuration
        run: |
          echo "ğŸ§ª Testing Docker Compose configuration..."
          
          # Create temporary .env for validation
          cat > .env << EOF
          POSTGRES_PASSWORD=test_password_123
          SECRET_KEY=test_secret_key_for_testing_purposes_minimum_fifty_chars
          NEXTCLOUD_ADMIN_PASSWORD=test_nextcloud_pass
          SUPERADMIN_PASSWORD=test_superadmin_pass
          PGADMIN_DEFAULT_PASSWORD=test_pgadmin_pass
          CORS_ALLOWED_ORIGINS=http://localhost:3000 http://127.0.0.1:3000
          POSTGRES_DB=colmena
          POSTGRES_USER=colmena
          POSTGRES_HOSTNAME=postgres
          POSTGRES_PORT=5432
          EOF
          
          # Validate docker-compose.yml syntax
          if docker compose config --quiet; then
            echo "âœ… Docker Compose configuration is valid"
          else
            echo "âŒ Docker Compose configuration has errors"
            exit 1
          fi
          
          echo "âœ… Docker configuration test completed successfully"

  test-summary:
    runs-on: ubuntu-latest
    needs: [workflow-validation, integration-tests, docker-basic-tests]
    if: always()
    steps:
      - name: Test Results Summary
        run: |
          echo "# ğŸ§ª Test Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          workflow_result="${{ needs.workflow-validation.result }}"
          integration_result="${{ needs.integration-tests.result }}"
          docker_result="${{ needs.docker-basic-tests.result }}"

          if [[ "$workflow_result" == "success" ]] || [[ "$workflow_result" == "skipped" ]]; then
            echo "âœ… **Workflow Validation**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Workflow Validation**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "$integration_result" == "success" ]] || [[ "$integration_result" == "skipped" ]]; then
            echo "âœ… **Integration Tests**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Integration Tests**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "$docker_result" == "success" ]] || [[ "$docker_result" == "skipped" ]]; then
            echo "âœ… **Docker Basic Tests**: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Docker Basic Tests**: Failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Test Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Type**: ${{ inputs.test_type || 'full' }}" >> $GITHUB_STEP_SUMMARY

          # Set overall status
          if [[ ("$workflow_result" == "success" || "$workflow_result" == "skipped") && ("$integration_result" == "success" || "$integration_result" == "skipped") && ("$docker_result" == "success" || "$docker_result" == "skipped") ]]; then
            echo "ğŸ‰ **Overall Result**: All tests passed!" >> $GITHUB_STEP_SUMMARY
            exit 0
          else
            echo "âŒ **Overall Result**: Some tests failed" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const workflowResult = "${{ needs.workflow-validation.result }}";
            const integrationResult = "${{ needs.integration-tests.result }}";
            const dockerResult = "${{ needs.docker-basic-tests.result }}";

            const getStatusEmoji = (result) => {
              if (result === 'success' || result === 'skipped') return 'âœ…';
              if (result === 'failure') return 'âŒ';
              return 'â¸ï¸';
            };

            const body = `## ğŸ§ª Test Pipeline Results

            | Test Type | Status | Result |
            |-----------|--------|---------|
            | Workflow Validation | ${getStatusEmoji(workflowResult)} | ${workflowResult} |
            | Integration Tests | ${getStatusEmoji(integrationResult)} | ${integrationResult} |
            | Docker Basic Tests | ${getStatusEmoji(dockerResult)} | ${dockerResult} |

            **Commit**: \`${{ github.sha }}\`
            **Test Type**: ${{ inputs.test_type || 'full' }}

            ${(workflowResult === 'success' || workflowResult === 'skipped') && (integrationResult === 'success' || integrationResult === 'skipped') && (dockerResult === 'success' || dockerResult === 'skipped')
              ? 'ğŸ‰ All tests passed! Ready for review.'
              : 'âŒ Some tests failed. Please check the logs and fix issues before merging.'}`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });